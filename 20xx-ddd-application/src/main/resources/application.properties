management.metrics.export.prometheus.enabled=true
management.metrics.export.prometheus.step=1ms
management.metrics.export.prometheus.descriptions=true

management.metrics.web.server.auto-time-requests=true
management.endpoints.web.exposure.include=*
management.metrics.tags.application=20xx-ddd-iot-application

#spring.boot.admin.url=${spring.boot.admin.url}

#eureka.client.service-url.defaultZone=http://localhost:9010/eureka/
#注：多个IP可以通过“，”
spring.cloud.nacos.discovery.server-addr=127.0.0.1:9010
#nacos客户端向服务端发送心跳的时间间隔，默认5s
#注：客户端向服务端每隔5s向服务端发送心跳请求，进行服务续租，告诉服务端该实例IP健康。若在3次心跳的间隔时间(默认15s)内服务端没有接受到该实例的心跳请求，则认为该实例不健康，该实例将无法被消费。如果再次经历3次心跳的间隔时间，服务端接受到该实例的请求，那么会立刻将其设置外健康，并可以被消费，若未接受到，则删除该实例的注册信息。推荐配置为5s，如果有的业务线希望服务下线或者出故障时希望尽快被发现，可以适当减少该值。
#spring.cloud.nacos.discovery.heart-beat-interval=5
#服务端没有接受到客户端心跳请求就将其设为不健康的时间间隔，默认为15s
#注：推荐值该值为15s即可，如果有的业务线希望服务下线或者出故障时希望尽快被发现，可以适当减少该值。
#spring.cloud.nacos.discovery.heart-beat-timeout=15
#给服务添加一些标签，例如属于什么业务线，该元数据会持久化存储在服务端，但是客户端消费时不会获取到此值，默认为空
#spring.cloud.nacos.discovery.metadata=
#命名空间ID，Nacos通过不同的命名空间来区分不同的环境，进行数据隔离，服务消费时只能消费到对应命名空间下的服务。
#spring.cloud.nacos.discovery.namespace:
#注：如果服务从注册中心只消费服务，没有对外提供服务，那么该值可设置为false，可减少客户端线程池的创建，无需向服务端发送心跳请求，提高性能。
#spring.cloud.nacos.discovery.register-enabled:




properties.jdbc.driverClassName=com.mysql.jdbc.Driver
properties.jdbc.url=0273a20d38cf3daca43abea56319a2013a0c69fda1a828015452b0e105cd6a0ce0fc283160dbdcffc056947a16f6c5938b141dfa2cdedad039b4b95bdb37d990551aa64a6e81c1cff8c9e1ecd1b21e44b9cf4cd829dfa30234d080a2e96cf301d648a8320b350c42a9366510d8a73a009bd02ed2be3001cb
properties.jdbc.username=04eb21457435b26f
properties.jdbc.password=345246e521a703df2f6250f16e8fad1f
#properties.jdbc.url=jdbc:mysql://192.168.88.207:3306/iot_eam?useUnicode=true&characterEncoding=UTF-8&useSSL=true&autoReconnect=true
#properties.jdbc.username=sieiot
#properties.jdbc.password=iphonexsie
properties.jdbc.validationQuery=SELECT 1
properties.jdbc.initialSize=20
properties.jdbc.maxActive=800
properties.jdbc.maxIdle=50
properties.jdbc.minIdle=20


#OSS文件服务器
properties.oss.endpoint=oss-cn-shanghai.aliyuncs.com
properties.oss.accessKeyId=LTAI1REGchOzIKKH
properties.oss.accessKeySecret=xnf3B4G9Zih5jxt3TIRct7E69NGZF2
properties.oss.bucketName=sieiotoss
properties.oss.accessProtocol=https://


#cassandra:
# Thingsboard cluster name
cassandra.cluster_name=Thingsboard Cluster
# Thingsboard keyspace name
cassandra.keyspace_name=sie_iot_dev
# Specify node list
cassandra.hosts= 139.9.147.53
cassandra.port=9042
# Enable/disable secure connection
cassandra.ssl= false

cassandra.query.ts_key_value_partitioning = MONTHS
cassandra.query.ts_key_value_ttl= 0

log.root.level=info
swagger.enable=true

# 如果为true，消费者的偏移量将在后台定期提交
kafka.consumer.enable.auto.commit = true
#如何设置为自动提交（enable.auto.commit=true），这里设置自动提交周期
kafka.consumer.auto.commit.interval.ms=1000
#order-beta 消费者群组ID，发布-订阅模式，即如果一个生产者，多个消费者都要消费，那么需要定义自己的群组，同一群组内的消费者只有一个能消费到消息
kafka.consumer.group.id = transQueue
#在使用Kafka的组管理时，用于检测消费者故障的超时
kafka.consumer.session.timeout.ms = 30000
kafka.consumer.key.deserializer = org.apache.kafka.common.serialization.StringDeserializer
kafka.consumer.value.deserializer = org.apache.kafka.common.serialization.StringDeserializer
kafka.consumer.concurrency = 1

#开启收集数据
#hc.enabled = true
##开启查看
#hc.read.enabled = true
##忽略要收集的api
#hc.ignoreApis = api/base/base-template/find-system-function,api/base/resource/find-resource,api/base/portal-favourite/find-user-menu,hc/hcPageController/find-pageinfo,api/base/base-user/logout,dyapi/baseDynamicApiController/pagination/unread-message-total,dyapi/baseDynamicApiController/pagination/message-find